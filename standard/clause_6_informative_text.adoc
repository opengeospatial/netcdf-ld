== Clauses not Containing Normative Material

=== Rationale and Design principles ===

netCDF is used widely in the environmental sciences for data capture, analysis and archival. netCDF as a format is used for encoding array-oriented earth- and space-science data. netCDF is an open Geospatial Consortium (OGC) standard. As netCDF can be, and is, used to store and disseminate a wide-range of multi-dimensional data types it is a natural format for encoding digital geospatial information. A number of widely used conventions exist in order to promote interoperability across netCDF files. The Climate and Forecast (CF) conventions in particular are a widely used in the encoding of geospatial data in netCDF and are also an OGC standard. Whilst this standard uses concepts which have grown out of the World Wide Web Consortium (W3C), namely the Linked Data approach, this standard builds specifically on netCDF and the outputs of OGC's netCDF Standards Working Group, hence this standard belongs in the OGC suite.

While netCDF allows metadata to be specified in each file, it lacks scalable mechanisms for specifying metadata that conforms to community or project conventions or standards. 
Conformance to metadata conventions is usually achieved by one-off tools for validation or limited to manual checking.
Linking to external resources on the web (e.g. controlled vocabulary terms, related files) can be implemented as simple strings in attribute values, however, the mechanism for implementing this is not standardised, nor are the tools to form knowledge graphs from these resources.

The netCDF-LD standard enables the annotation metadata in netCDF files in a way that is interoperable and reusable, and with minimal changes to current netCDF syntax. This means existing files can be interpreted using netCDF-LD tools.  
netCDF-LD proposes mechanisms such as encoding rules that allow users to precisely reference shared attribute names (e.g. property names) and shared values (e.g. controlled vocabulary terms). 
This facilitates consistency in specifying metadata across netCDF files.
These netCDF-LD mechanisms thus allow existing netCDF files to be interpreted as Linked Data, and this facilitates  interoperability between netCDF files (and potentially non-netCDF data files).
Therefore, data providers adopting netCDF-LD are able to interpret existing standard netCDF metadata as well as annotate additional metadata in netCDF files that conform to one or more metadata conventions in a consistent way.

A key aspect of netCDF-LD is the introduction of rules for mapping identifiers for netCDF global and variable attributes and variables to Uniform Resource Identifiers (URIs) via _prefix_ and _alias_ mechanisms. 
URIs or identifiers are the building blocks for defining unambiguous semantics via concept definitions and relationships between concepts.
Using these mechanisms, netCDF-LD provides a way to disambiguate attribute names and values shared among different netCDF files via identifiers.

netCDF's current use allows up to petabytes of data to be written out, sometimes organised as data files in series across thematic (observable properties), temporal (daily, monthly, yearly) or geographic regions. 
Users of the data may want to query or discover from those files.
The current tools for handling this include software such as THREDDS and ERRDAP that provide APIs and functionality for searching and discovery.

netCDF-LD enables the potential for search and discovery in a different way to current netCDF software tools by leveraging the Linked Data representation of netCDF metadata as knowledge graphs. netCDF-LD allows summary metadata from any netCDF file to be extracted to provide an external description of the file in RDF.  
This enables references to externally published resources in RDF-specified metadata conventions.  
These descriptions can be used with other Linked Data technologies including the RDF query language, SPARQL (Harris and Seaborne 2013), and RDF triple stores.
These descriptions can also be used to support data fusion from other data sources that have RDF representations also, i.e. non-netCDF data sources.

In summary, netCDF-LD provides mechanisms that allow interpreting and annotation of metadata to conforms to community or project conventions/standards in a consistent way leveraging Linked Data approaches. In doing so, netCDF files are able to be interpreted into RDF graphs, which in turn can be used with other Linked Data technologies for data fusion, powerful querying and data discovery. 


//In summary, the key objectives motivating this standard are:
//* Provide a mechanism for precise annotation of metadata to enhance the clarity of metadata contained within netCDF files, which may implement multiple metadata conventions
//* Provide a mechanism for extracting the metadata of netCDF files and aggregating the extracted metadata

==== Design principles ====

- **Compatible with existing netCDF encoded files**. netCDF-LD encoded files should be compatible with existing netCDF encoded files. This means existing netCDF libraries can be used to parse files which have been encoded as netCDF-LD. This also ensures that netCDF-LD encoded files can be used as simply as netCDF, with no knowledge of RDF.
- **Existing netCDF encoded files can be used with netCDF-LD tools**. Existing netCDF files can be used with netCDF-LD files. That is, existing netCDF files can be represented as RDF using netCDF-LD tools.
- **Default behaviour while preserving flexibility**. netCDF-LD mechanisms and implementations should have consistent and useful default behaviour/configuration, but allow for user-defined configuration if needed.
- **Explicit semantics**. netCDF-LD promotes explicitly specifying semantics even if they implicit in netCDF files, e.g. aliases for well-known netCDF attribute names are made with explicit web-resolvable identifiers.
- **Leverage existing Linked Data approaches and tools**. The netCDF-LD standard should promote and adopt existing web and Linked Data approaches tools rather develop bespoke functionality, e.g. query language for netCDF-LD RDF content should use SPARQL.


//==== Motivating Scenarios



=== Resource Description Framework

The _Resource Description Framework (RDF)_ is a W3C standard (Hayes and Patel-Schneider 2014).  Information elements consist of RDF statements. An RDF statement consist of three parts: _Subject_, _Predicate_, and _Object_. This is called a _triple_.

Identifiers are a key building block of RDF and _Uniform Resource Identifiers (URIs)_ are used to identify a resource. URIs can appear in each part of a triple, i.e. _Subjects_, _Predicates_ and _Objects_. Where an _Object_ is a _URI_, this may also be a _Subject_ for another statement.

Literals are another key part of RDF and are used to capture basic values other than a URI. e.g. strings such as "Gerald", dates such as "1 April 2019", and numbers such as "4897". Literals are associated with a data-type so that they can be parsed. Literals may only appear in the _Object_ part of a RDF statement. 

RDF statements are collected together within an _RDF Graph_. Figure 1 below show an example of an RDF graph encoding information about the singer B.B. King.

[#figure-1]
.RDF Example: BB King
image::bb-king-rdf-example.png[Figure 1. RDF Example: BB King]

```
<B.B. King> <is a> <person>.
<B.B. King> <is born on> <the 16th of September 1925>. 
<B.B. King> <plays instrument> <guitar>
```

The netCDF-LD standard maps the netCDF data model encoding onto the RDF information model.


=== NetCDF File

The Unidata network Common Data Form (netCDF) is an interface for scientific data access and a freely-distributed software library that provides an implementation of the interface. The netCDF library also defines a machine-independent format for representing scientific data (https://github.com/Unidata/netcdf-c), which may consist of multiple dimensions (Figure 2 and Figure 3).

NetCDF is an encoding format with open semantics and inferred referencing.  Metadata may be defined on all variables and groups within a netCDF file, with each entity having its own name space for locally unique attribute names and each attribute containing a single value.

For targeted metadata specifications, such as defining referenced spatio-temporal coordinates, metadata conventions are used.

Metadata conventions and internal referencing enable a detailed representation of semantics describing the arrays of data values encoded within the file.

// example diagram from scitools

[#figure-2]
.Multi-dimensional Array
image::multi_array.png[Figure 2. Multi-dimensional Array]

[#figure-3]
.Array with Arrays Defining Dimensions
image::multi_array_to_cube.png[Figure 3. Array with Arrays Defining Dimensions]

// variables

// references

// dimensions

// (one of the core issue to address in this specification is how to provide variable to variable referencing)


=== RDF Vocabularies

A set of RDF vocabularies are used within this standard to allow the representation of structural and semantic content of netCDF metadata within the context of an RDF graph. Where possible widely adopted RDF vocabularies are used before creating new vocabularies. This allows the ability to combine data graphs from different sources, promotes data harmonisation, and the ability to query them in an interoperable way (i.e. using the same vocabularies and predicates for like-for-like semantics).

A new vocabulary is defined by the Open Geospatial Consortium, the Binary Array Linked Data vocabulary: `bald` (https://www.opengis.net/def/binary-array-ld/). The `bald` vocabulary (Figure 4) defines a small set of concepts which enable the structural elements of generic binary array containers, including netCDF, to be represented within an RDF graph. 

This standard also makes use of the core RDF vocabularies, the Dublin Core vocabulary,  the schema.org vocabulary and the Data Catalogue Vocabulary (DCAT):

* rdf (http://www.w3.org/1999/02/22-rdf-syntax-ns#)
* rdfs (http://www.w3.org/2000/01/rdf-schema#)
* dct (http://purl.org/dc/terms/)
* sdo (http://schema.org)
* dcat (http://www.w3.org/ns/dcat#)


[#figure-4]
.Binary Array Linked Data (BALD) vocabulary
image::bald-ont-2.png[Figure 4. BALD vocabulary]


=== Metadata RDF Graph

An _RDF graph_ representing the metadata of multiple files provides a valuable resource for summarising the file collection.

The numerical data within the file is not encoded within the graph, only the metadata.  In general, this means that the graph is orders of magnitude smaller than the data file it summarises.

Having an _RDF graph_ of metadata across a file collection enables the use of Semantic Web technologies to explore, interrogate and visualise the metadata from that file collection in a variety of ways. In Figure 5, an example is given showing the CF standard name attribute value across multiple files.

[#figure-5]
.Example showing cf:standard_name property values across different files
image::metadata-across-files-example.png[Figure 5. Example showing cf:standard_name property values across different files.]

Representing this and other metadata enables queries across netCDF files, e.g. find netCDF files that have data values on  `sea_surface_temperature`.

The following sections of this standard define how to interpret a netCDF file as an RDF metadata graph.

Multiple graphs may be combined into a single multi-file metadata graph providing individual file identities are unique across the multi-file metadata graph.

// ==== Processing Model

// indicative

// one identifier
// plus
// external aliases
// plus
// input file
// produces one rdf graph output

==== Uniform Resource Identifiers within netCDF files

At the core of this standard is the mechanism for encoding and interpreting Uniform Resource Identifiers (URIs) within netCDF files.

These URIs may be declared explicitly within the files, or interpreted from file metadata and external information sources.


==== Identity

In netCDF-LD, a _netCDF file_ has an identity.  This identity provides the mechanism to obtain the file.  As it is mutable, it is dependent on how the file is provided.  Two systems may provide an identical file, but in different ways, and decide to use different identities. The identity is not inherent to the metadata payload of the file.

An explicit identity, i.e. a URL or URI, may be provided during file interpretation (i.e. by netCDF-LD parsers).

If no identity is provided, then the file path (`file:`) or remote location (`http:` / `https:`) used by a library to access the file is used as a default identity.
If used, a local file URI will always use the '/' forward slash as an element separator, even on systems where local identifiers use back slash separators.


The identifier for the netCDF file is the identity of the root group, that is, the base entity within the netCDF file. This provides an identity root for the contents of the file. For this reason, this standard mandates that the identifier string will always terminate in a '/' character.  In this way the root group's identity is distinguished as a different conceptual entity from the file itself.

Two examples are provided below showing a file URI from a location, via a URL, which also serves as a URI for that file object (Example 1).  Example 2 shows the root group, within that file, may reuse the identity string, as a compound part, with the addition of the extra '/' character, thereby differentiating itself from the file object identity.

1. Example 1. https://www.unidata.ucar.edu/software/netcdf/examples/test_hgroups.nc (the URI identity of the netCDF file object)
1. Example 2. https://www.unidata.ucar.edu/software/netcdf/examples/test_hgroups.nc/ (the URI identity of the root group contained within that netCDF file object)

===== Variable Identity 

Each netCDF variable within the root group, each netCDF group and each netCDF variable within each group shall take its identity as a URI, relative to the file identity.

This identity is defined using the full variable name, including any owning groups, appended to the file identity. Each element separation uses the `/` character.

Thus, each variable and group within that file has its own identity, defined relative to the file identity.

===== Variable Type Declaration

Each netCDF variable shall declare a type statement, and RDF triple of the form

----

<variableURI> rdf:type <type>

----

There are two recognised type identifiers within the standard. 

====== Array Variable Type Identifiers

If the variable contains an array data payload (which may be missing data) then the type shall be defined as bald:Array and shall include a statement defining the shape of the data payload array as a Literal encoded tuple of integer values, using bald:shape.

The shape Literal is the shape as defined and ordered within the netCDF file, using the numerical values of the dimensions to define the actual shape.

The names of dimensions within the netCDF file encoding are not stored within the metadata summary graph.

----

<variableURI> rdf:type bald:Array ;
              bald shape (1,1,16,9) .

----

====== Resource Variable Type Identifiers

If there is no array payload and the variable is single valued (which may be missing data) then the type shall be defined as bald:Resource.  

In the bald vocabulary, bald:Resource is the general type, bald:Array is a specialisation of this type.


----

<variableURI> rdf:type bald:Resource .

----
 
If the bald:Array instance has a single dimension, then the first and last values from the data payload, as ordered within the netCDF file, shall be encoded as Literals within the metadata graph, using bald:firstValue and bald:lastValue.

For example:
----

<variableURI> rdf:type bald:Array ;
              bald shape '(72,)' ;
              bald:firstValue -90 ;
              bald:lastValue 90 .

----



===== Download URL

The identity is conceptually distinct from the resolvable location of a file.

Identity and Download URL are optional inputs to the metadata graph creation process.

If a download URL is provided, but no Identity is provided, then an identity shall be inferred by the appending of a '/' character to the location.

If a download URL is provided, then it shall be recorded as part of the `dcat:distribution` definition.

As a bald:Container is a subclass of dcat:Distribution, DCAT is used to describe the file type and to provide an optional statement to specify the resolvable location of the file object, using dcat:downloadURL.

----
@prefix this: <https://raw.githubusercontent.com/opengeospatial/netcdf-ld/v0.2/standard/abstract_tests/netCDF/ogcClassEF.nc/> .

this: a bald:Container ;
 dcat:distribution [
 	a dcat:Distribution;
 	dcat:downloadURL <https://raw.githubusercontent.com/opengeospatial/netcdf-ld/v0.2/standard/abstract_tests/netCDF/ogcClassEF.nc>;
 	dcat:mediaType [
 		a dct:MediaType;
 		dct:identifier "application/netcdf"
 	];
 	dct:format [
 		a dct:MediaType;
 		dct:identifier <http://vocab.nerc.ac.uk/collection/M01/current/NC/>
 	]
                 ].

----

netCDF-LD implementations shall enable the file location to be provided at run time, separate from the identity, to define from where the file object may be obtained.

netCDF-LD implementations shall not provide a dcat:downloadURL statement unless specified at run time.

==== Containment

bald:Container instances use a simple containment behaviour, provided by the `bald:contains` property to represent the containment of variables and groups within groups and files.

==== Prefix Definition

In netCDF-LD, the _prefix_ is a mechanism to encode explicit URIs from elements in the _netCDF file_. It is the most straightforward and the most powerful way of doing so. It has two parts: the first part is the declaration of a prefix (or a set of prefixes), the second part is the use of the prefix.

Prefixes are in wide use in a number of domains, including XML and RDF. They allow a URI to be expressed in a compact fashion that saves space, enhances human readability and can mitigate issues with reserved characters.

===== Prefix Declaration in File

Prefixes may be declared inside the file using a name-value-pair that associates a short name (e.g. `cf__`, `bald__`), with a URI.

The attributes defining prefixes shall be in a separate netCDF group or variable, as attributes.

The prefixes group shall not be interpreted as part of the graph, it is used only in the interpretation of URIs, which will be encoded as explicit RDF prefixes in RDF encodings.

A single prefix declaration is an attribute and a value: the attribute name is the prefix name and the attribute value is the full URI for that prefix. e.g.

----
  bald__ = https://www.opengis.net/def/binary-array-ld/
----

The 'double underscore' character pair: `__` is used as an identifier and as the termination of the prefix; the double underscore is part of the prefix string within the netCDF file.

The double underscore is interpreted as a special character by this standard: the first use of a double underscore from the start of any string shall be interpreted as a prefixed entity and shall be unpacked into full URIs by aware software if a full URI is defined.

A prefix defined within a file shall only be used as a prefix if it ends in a double-underscore character pair, `__`.

Prefixes are applied across the file they are declared within.  A single dedicated group shall be used to contain all of the internally defined prefixes applied to that file.

The prefix group is optional.

If included the prefixes group shall be identified within the file by a single global attribute, using the attribute name `bald__isPrefixedBy`.

If included, the prefixes group shall include the `bald` prefix declaration.

The definition of multiple prefix resources within a single file is invalid in this standard. 
netCDF-LD implementations may choose to combine prefix collections in invalid cases, but no precedence is implied, and prefix conflict is unresolved. 
netCDF-LD implementations may treat this condition as a warning condition and as a validation error.

====== The Double Underscore Syntax

This standard introduces a special text syntax, a double underscore '__' as a separator between the prefix and suffix.

The choice of special character has been chosen as a compromise of various factors.  RDF uses a ':' (colon) as a separator between prefix and suffix, but the netCDF CDL specification uses the colon as a variable attribute separator.  As such, the use of a colon as a separator requires escape characters to be used.

Older versions of the netCDF libraries precluded the use of colon at all, the ability to use the escape character was introduced, but some use of double underscore was already in use in ad-hoc file encodings.  Maintaining backwards compatibility is deemed a useful facet of this syntax.

The use of attribute names with colon separators is a limiting factor in writing code, as the attribute name can only be used within a string in many programming languages (e.g. python), and not as a variable name or identifier.

Early adopters of the approaches being standardised in this document have been using the double underscore to namespace locally defined attribute names for a significant period of time, in the hope that this syntax would become standardised.  There is fairly widespread use of this namespace syntax in existing files across a number of archives of earth system geospatial data.

Given the ad-hoc usage of the double underscore and its utility in programming languages and data specifications, this standard adopts and standardises the double underscore as the prefix separator for this standard.

===== Externally Defined Prefixes

Prefixes may be defined at runtime, by providing parse-able JSON-LD context files or contents.

Prefixes will be interpreted during parsing from all context files and internally defined prefixes in combination.

Prefixes in context files shall be defined as RDF prefixes in JSON-LD.  This means that there is no prefix separator within the JSON-LD context file.  The prefix, defined in the JSON-LD context file shall be interpreted as the prefix string appended by a double-underscore `__` within the netCDF-LD contextual interpretation.

For example, the prefix `bald` would be defined within a JSON-LD context file as:
----
{'@context': {'bald': 'https://www.opengis.net/def/binary-array-ld/'}}
----

The parsing library would interpret this as equivalent to the definition of a prefix within a file in CDL:

----
group: prefix_list {
    :bald__ = "https://www.opengis.net/def/binary-array-ld/" ;
    }
----

and thus match to attributes within the file, such as in CDL:
----
// global attributes:
                :bald__isPrefixedBy = "prefix_list" ;
----


===== Prefix Conflict

If a prefix string is defined multiple times in JSON-LD context files, with different URI interpretations, then implementations shall ignore that prefix and treat the prefix as locally unresolved.
Implementations may choose to raise warnings, validation errors, etc. in these cases.

It is expected that files will be able to be parsed, even if prefix conflicts exist. Conflict in prefix definitions is not a violation of this standard, the fall-back position is to ignore conflicting prefixes as not well defined at runtime.

Prefix definitions provided explicitly within a file shall not be over-ridden by context files.  Prefixes defined within a file have precedence.

If a prefix defined within a file is also defined within provided JSON-LD context files with different URI interpretations, then implementations shall ignore that JSON-LD context definition and treat the prefix as locally resolved.

This standard does not consider this as a parsing error.

Implementations may treat this condition as a warning condition and as a validation error within the provided context.


===== Prefix use

A prefix is used with netCDF file elements as:
----
  <prefix><name>
----

This is interpreted within this standard as a URI, a concatenation of the matching value within the prefix variable and the remainder of the attribute name or value.

The attribute name
----
  bald__isPrefixedBy
----
together with the prefix definition
----
  bald__ = https://www.opengis.net/def/binary-array-ld/
----
is interpreted as
----
  bald__isPrefixedBy = https://www.opengis.net/def/binary-array-ld/isPrefixedBy
----

Prefixes shall end in a URI separator, either a `/` or a `#`.  

The following example, in netCDF Common Data Language (CDL), uses the link:++binary-array-ld.net++[https://www.opengis.net/def/binary-array-ld] and the `w3.org rdf-syntax-ns` vocabularies to describe a reference relationship between two variables.

----
netcdf tmpMwXy8U {
dimensions:
	pdim0 = 11 ;
	pdim1 = 17 ;
variables:
	int a_variable(pdim0, pdim1) ;
		a_variable:rdf__type = "bald__Array" ;
		a_variable:bald__references = "b_variable" ;
	int b_variable(pdim0, pdim1) ;
		b_variable:rdf__type = "bald__Reference" ;
		b_variable:bald__array = "b_variable" ;

// global attributes:
		:bald__isPrefixedBy = "prefix_list" ;
group prefix_list {
    :bald__ = "https://www.opengis.net/def/binary-array-ld/" ;
    :rdf__ = "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ;
}
}
----

In this example:

* `rdf__type` is interpreted as http://www.w3.org/1999/02/22-rdf-syntax-ns#type
* `bald__array` is interpreted as https://www.opengis.net/def/binary-array-ld/array



==== Alias Definition

Alongside the definition of prefixes, explicit aliases may be defined via netCDF-LD conventions within the _netCDF file_, or as a scope for a _netCDF file_ during parsing.  Aliases enable controlled attribute names to be interpreted as URIs.

Alias definitions do not exist with file CDL.  They are provided as input (either as RDF or JSON) to a parsing process at parse time, from external vocabularies.

Alias URIs are interpreted from a reverse lookup from the file into the graph.  Consequently there is no protection against name clashes.

For an entity in an alias graph to be considered as an alias, the entity will define a RDF statement:

----
  <$entity> <http://purl.org/dc/terms/identifier> "$Literal" .
----

The Literal object of this RDF statement is the alias name.

An alias that may be used as an attribute name alias shall define its Type as

----
  <$entity> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/1999/02/22-rdf-syntax-ns#Property> .
----

or

----
  <$entity> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2002/07/owl#ObjectProperty> .
----


The alias mechanism is less flexible than the prefix mechanism. It does enable interpretation of attribute names directly, making it useful for existing standards and existing files.

Aliases are applied across the file for which they are declared.

Aliases are declared as a set of RDF graphs. These RDF graphs are commonly provided as URIs, to be obtained during parsing and file metadata interpretation.

The RDF graphs shall be combined and treated as a single alias scope for the file.

An example of alias definitions in an external file is shown below ,encoded as TTL in a separate file for names.

----
# Names Aliases
@prefix dct: <http://purl.org/dc/terms/> .
@prefix skos: <http://www.w3.org/2004/02/skos/core#> .
@prefix acdd: <https://def.scitools.org.uk/ACDD/> .
@prefix cfterms: <https://def.scitools.org.uk/CFTerms/> .
@prefix nc: <https://def.scitools.org.uk/NetCDF/> .
@prefix op: <http://environment.data.gov.au/def/op#> .

acdd:id                 dct:identifier "id" .
acdd:title              dct:identifier "title" .
cfterms:standard_name   dct:identifier "standard_name" .
cfterms:units           dct:identifier "units" .
nc:valid_min            dct:identifier "valid_min" .
nc:valid_max            dct:identifier "valid_max" .
op:matrix               dct:identifier "matrix" .
op:objectOfInterest     dct:identifier "substanceOrTaxon" .
skos:prefLabel          dct:identifier "prefLabel" .
----


The following shows the RDF example as a JSON-LD serialization:
----
{
  "@context": {
    "dct": "http://purl.org/dc/terms/",
    "xsd": "http://www.w3.org/2001/XMLSchema#",
    "acdd": "https://def.scitools.org.uk/ACDD/",
    "cfterms": "https://def.scitools.org.uk/CFTerms/",
    "nc": "https://def.scitools.org.uk/NetCDF/",
    "skos": "http://www.w3.org/2004/02/skos/core#",
    "op": "http://environment.data.gov.au/def/op#"
  },
  "@graph": [
    {
      "@id": "skos:prefLabel",
      "dct:identifier": "prefLabel"
    },
    {
      "@id": "acdd:id",
      "dct:identifier": "id"
    },
    {
      "@id": "acdd:title",
      "dct:identifier": "title"
    },
    {
      "@id": "cfterms:standard_name",
      "dct:identifier": "standard_name"
    },
    {
      "@id": "cfterms:units",
      "dct:identifier": "units"
    },
    {
      "@id": "op:matrix",
      "dct:identifier": "matrix"
    },
    {
      "@id": "op:objectOfInterest",
      "dct:identifier": "substanceOrTaxon"
    },
    {
      "@id": "nc:valid_max",
      "dct:identifier": "valid_max"
    },
    {
      "@id": "nc:valid_min",
      "dct:identifier": "valid_min"
    }
  ]
}
----

Alias definitions, provided as input as a simple dictionary representation, are available as JSON. The alias dictionary representation encoded as JSON shall consist of only an object with name/value pairs for the alias and the mapped URI respectively. The value for an item in the JSON object shall be a string value for the URI. 

An example of aliases for both names and values, expressed as a dictionary encoded as a JSON file, is shown below:
----
{
        "id"                             : "https://def.scitools.org.uk/ACDD/id",
        "title"                          : "https://def.scitools.org.uk/ACDD/title",
        "standard_name"                  : "https://def.scitools.org.uk/CFTerms/standard_name",
        "units"                          : "https://def.scitools.org.uk/CFTerms/units",
        "valid_min"                      : "https://def.scitools.org.uk/NetCDF/valid_min",
        "valid_max"                      : "https://def.scitools.org.uk/NetCDF/valid_max",
        "matrix"                         : "http://environment.data.gov.au/def/op#matrix",
        "substanceOrTaxon"               : "http://environment.data.gov.au/def/op#objectOfInterest",
        "prefLabel"                      : "http://www.w3.org/2004/02/skos/core#prefLabel"
}
----

==== Attribute Names

In order to map netCDF metadata to RDF, all global and variable attributes are interpreted as RDF statements.  This requires that all attribute names are interpreted as URIs.

A parsing process shall map attribute names to URIs using prefix definitions first, then map attribute names to URIs aliases.

An attribute name shall be mapped to an alias URI if, and only if, there is an exact match for the full attribute name as a `dct:identifier` (expand to full URI) for an entity within the alias graph where that entity declares a RDF statement within its defining graph.

----
  <entity> <rdf:type> <rdfs:ObjectProperty> .
----

That defining graph needs to be provided to netCDF-LD aware software at the time of parsing the file, so that it can be interpreted.

An error is created if multiple aliases match an attribute name in a _netCDF file_ due to a conflict in unambiguously identifying the declared alias scope.

All remaining attribute names shall be mapped to local identifiers, using the file identity and variable identity (`ref{}`) to form a locally applicable URI.

In the examples, the prefix `this:` is used within the graphs as the file identifier.

==== Variable-to-Variable References

The value of an attribute may be a reference to another variable, or multiple variables.
The process of establishing identity for each variable within the file enables this reference to be interpreted as a URI.
In this way, the RDF approach to having objects that are links to subjects, chaining RDF statements into graphs, is implemented.

For a reference to be identified, the predicate that defines that reference must identify itself as suitable for variable-to-variable referencing.  No references will be inferred for predicates that do not identify themselves in this way.

To identify a predicate as a variable-to-variable reference predicate, that predicate shall provide a RDF statement that explicitly opts into this behaviour.  The simplest way to do this is to include the RDF statement.

----
  <{predicate}> rdfs:range bald:Resource .
----

Alternatively, it is permissible to provide an rdfs:range statement targeting another resource and for that resource to declare that it is an rdfs:subClassOf bald:Resource:

----
 <{attribute}> rdfs:range <{AClass}> .

 <{AClass}> rdfs:subClassOf <https://www.opengis.net/def/binary-array-ld/Resource> .
----

This standard supports direct rdfs:subClassOf relations to enable variable to variable references. This standard does not support nested derivation, thus an implementation is not required to search the inheritance tree of a defined Class to see if any of the classes, which it inherits, define themselves as rdfs:subClassOf bald:Resource.

The definition of the owl:objectProperty bald:references uses this rdfs:range, rdfs:subClassOf definition within the bald ontology: https://www.opengis.net/def/binary-array-ld

----

<https://www.opengis.net/def/binary-array-ld/references>
        a                owl:ObjectProperty ;
        rdfs:domain      <https://www.opengis.net/def/binary-array-ld/Array> ;
        rdfs:label       "references" ;
        rdfs:range       <https://www.opengis.net/def/binary-array-ld/Reference> ;
        dct:description  "This Array references that Reference. " .

<https://www.opengis.net/def/binary-array-ld/Reference>
        a                owl:Class ;
        rdfs:label       "Reference" ;
        rdfs:subClassOf  <https://www.opengis.net/def/binary-array-ld/Resource> ;
        dct:description  "The definition of a reference from one Array to another." .
----

References to variables are implemented in netCDF files by defining the value of an attribute as the name of a variable, or as a space-separated set of names of variables, or as a parenthesis bound, space-separated, list of names of variables.

A set of references is explicitly unordered whilst a list of references is explicitly ordered.

CDL defining a set of references:
----
  int set_collection ;
    set_collection:bald__references = "data_variable1 data_variable2" ;
----

will be interpreted into RDF(turtle) as:
----
  ns1:set_collection a bald:Resource ;
      bald:references ns1:data_variable1_ref,
                      ns1:data_variable2_ref .
----


CDL defining a list of references:
----
  int list_collection ;
    list_collection:bald__references = "( data_variable1 data_variable2 )" ;
----

will be interpreted into RDF(turtle) as:
----
  ns1:list_collection a bald:Resource ;
      bald:references ( ns1:data_variable1 ns1:data_variable2 ) .
----

//All variable names shall be within the file, or no references shall be interpreted.  There shall be no partial matching.

If matching fails, the fall-back option is to ignore the potential for references and leave the attribute value as a Literal.

==== Attribute Values

In RDF, objects may be Literals or URIs, therefore attribute values are conditionally interpreted as Literals or as URIs.
A parsing process shall map attribute values to URIs using identified prefixes first.

===== Attribute Variable References

The value of a variable attribute may be an internal reference to another variable within the file.

For an in-file variable reference to be declared, three conditions shall be met.

1. Condition one: the value is a string which exactly matches the name of a variable within the file.
** netCDF LD uses the rules for referencing variables across groups defined by the CF Conventions for netCDF Files:
*** (http://cfconventions.org/cf-conventions/cf-conventions.html#groups);
*** 'search by absolute path' and 'search by relative path' shall be implemented;
*** 'search by proximity' is deprecated by CF, and may be implemented or not.
1. Condition two: the attribute name is already interpreted as a URI, defining an entity, external to the file.
1. Condition three: the attribute name entity declares an `<rdfs:range>` of `<bald:Resource>` (or uses rdf:subClassOf linkage).

An identified attribute reference shall map the attribute value to the identify of the matched variable within the file.

This identification takes place after prefixes are identified and mapped.

===== Attribute Value Aliases

After prefix and reference interpretation, remaining attribute values are mapped to URIs using the alias graph.

An attribute value shall be mapped to an alias URI if and only if there is an exact match for the full attribute value as a `dct:identifier` (expand to full URI) for an entity within the alias graph.

If multiple aliases match an attribute name, this is an error condition, the declared alias scope cannot be uniquely applied to the file.

===== Attribute Value Literals

All remaining attribute values shall be left unchanged and declared as instances of `<rdf:Literal>`.

==== Reference Exceptions

The BALD vocabulary elements:

----
bald:isPrefixedBy
bald:isAliasedBy
----

are exceptions within the standard.  

They are variable to variable reference definitions, to provide capability within this standard. They are not metadata content for the file metadata summary.

----
bald:isPrefixedBy
bald:isAliasedBy
----

statements shall not be represented within the standard output metadata graph. 
Target variables and groups from these variable to variable references shall be omitted from the output metadata graph.


=== NetCDF Dimensions

NetCDF makes strong inferences regarding how variables are defined by dimensions.

NetCDF files define named dimensions, `dims`.  Each dimension defines a size, which is used as an array dimension.  NetCDF Variables use dimensions to define their size and shape and to define some implicit references between each other (Figure 6).

In this way the netCDF variables are defined with respect to shared dimensions (Figure 7).

[#figure-6]
.Multi-dimensional Array
image::multi_array.png[Figure 6. Multi-dimensional Array]

[#figure-7]
.Array with Arrays Defining Dimensions
image::multi_array_to_cube.png[Figure 7. Array with Arrays Defining Dimensions]

NetCDF-LD uses the dimensions to interpret the size and shape of a variable array.

NetCDF-LD does not explicitly encode the dimensions: only the sizing and referencing information.  In cases where dimensions do not have a netCDF coordinate variable defined, this results in the name of the dimension being lost.

Extensive Variables are variables defined with respect to one or more dimensions.

In netCDF-LD, the size and shape of each extensive variable is explicitly stored as a RDF statement made with respect to that variable.  The predicate bald:shape is used.  Objects of this predicate shall be `rdf:Literal` instances.

Each extensive variable shall be described by a RDF statement.

----
  <$entity> <https://www.opengis.net/def/binary-array-ld/shape> ($d0 $d1 $d2)
----

where `$dn` is an integer, taken from the defined dimension size in the netCDF file, and the count of the number of values is the dimensionality of the variable.

The object of this statement is an RDF List.

==== Broadcasting

In order to interpret netCDf dimensions within RDF graphs, the concept of Broadcasting is presented here, and used to implement array referencing.

Broadcasting enables arrays which share some dimensions, but have different overall dimensionality, to be interpreted together.  Two arrays may be broadcast if the dimensions they share are ordered the same and extra dimensions can be interpreted unambiguously.

The result of broadcasting is an array shape which can represent the contents of each of the two input arrays, with extra dimensions containing copies of the defined values.  In other words, an array may be stretched 

In this way, an array location in the broadcast result array can interpret one, and only one, value from each of the input arrays.

The concept of broadcasting is defined in the Python Numpy library https://numpy.org/devdocs/user/basics.broadcasting.html, from where Figures 8-11 and the associated descriptions are sourced.

[#figure-8]
.Scalar b is stretched to become an array of same shape as a so the shapes are compatible for element-by-element multiplication
image::theory.broadcast_1.gif[]

[#figure-9]
.A one dimensional array added to a two dimensional array results in broadcasting if number of 1D array elements matches the number of 2D array columns
image::theory.broadcast_2.gif[]

[#figure-10]
.When the trailing dimensions of the arrays are unequal, broadcasting fails because it is impossible to align the values in the rows of the 1st array with the elements of the 2nd arrays for element-by-element addition
image::theory.broadcast_3.gif[]

[#figure-11]
.In some cases, broadcasting stretches both arrays to form an output array larger than either of the initial arrays
image::theory.broadcast_4.gif[]

==== Shape and Reshape

In order to describe the results of the broadcast concepts in an implementation neutral fashion, this standard uses the shape and the concept of reshape.

The shape of an array is an ordered list of integers, representing the dimensionality of a multi-dimensional array and the size of each dimension.

Reshape is an operation which changes the dimensionality of an array, whilst preserving the number of values within the array.

Any array shape may be reshaped by adding elements to the array shape list, where the added items are of size 1.  In situ elements of the shape that are not size 1 may not be reordered by a reshape.

For example:

----
bald:sourceRefShape (5, 9)
bald:targetRefshape (1, 1, 5, 9, 1)
----




==== Variable References and Dimensions

NetCDF-LD uses the defined netCDF dimensions to interpret references between variables and to interpret how the shapes of the variable arrays relate.

Each variable reference between variables defined with respect to netCDF dimensions is assumed to be an array-to-array relationship and that the arrays can be broadcast to enable a common indexing approach.

Broadcast is defined as extending an array along each of a set of defined dimensions, each of size 1, by copying the contents of the array for each array index up to the defined size.  This enables an array to match shape with another array. 

This interpretation means that it can be expected that the target in the reference relationship can be viewed with a dimensionality consistent with the source.  A new shape is defined, with reshape, for the source and target, with size one values for dimensions that are to be broadcast.  This imposes ordering of the dimension for the broadcast operation.

Note: this is a key feature of netCDF dimensions: defining the size and commonality of array dimensions for variables.

In each case where a variable-to-variable reference is inferred within a netCDF file and both of the variables are defined with respect to one or more dimensions, the nature of that reference from the perspective of the arrays will be explicitly encoded within the RDF graph.

The inferencing of how array dimensions are matched and how this enables the interpretation of array broadcasting is subtle and implicit in netCDF, and specific to netCDF.

This information is unpacked and stored in a general fashion within the RDF graph.

All extensive variables have a shape encoded in the RDF graph.  In order to interpret references, it is commonly required that a RDF statement, similar to the shape, is encoded, showing the reshaped shape that an array needs to be in order to properly broadcast.
NetCDF-LD explicitly includes all reference RDF statements, even where the broadcast relationship can be inferred, for clarity and to aid comprehension.

A refshape array shape has the same total number of elements as the original array, but includes extra dimensions, of size 1, defining the order which the extensive dimensions are handled in.

To hold this information, netCDF-LD creates a new entity within the graph, representing this relationship, a `<$referenceEntity>`.

This `<$referenceEntity>` is referenced by the `<$sourceEntity>` using the predicate `<https://www.opengis.net/def/binary-array-ld/references>`, i.e.:

----
  <$sourceEntity> <https://www.opengis.net/def/binary-array-ld/references> <$referenceEntity>
----

The `<$referenceEntity>` is defined to be of type `<https://www.opengis.net/def/binary-array-ld/Reference>` and shall define a single statement defining the target entity in the relationship, another variable in the file, using the predicate `bald:target`. The `<$referenceEntity>` shall define a `bald:targetShape` statement defining the reshape expansion of the target array.
The `<$referenceEntity>` may  define a `bald:sourceRefShape`, where that source shape is required to be different from the defining shape of the source array.
The `<$referenceEntity>` shall  define a `bald:targetRefShape`, whether that source shape is required to be different from the defining shape of the source array or whether the shape is the same.

In this manner, the source array and the target array are defined with a common dimensionality enabling the shape to be unambiguously defined for broadcasting; i.e.:

----
  <$referenceEntity> a <https://www.opengis.net/def/binary-array-ld/Reference> ;
      <https://www.opengis.net/def/binary-array-ld/sourceRefShape> ($d1 <$d2 $d3 ...>) ;
      <https://www.opengis.net/def/binary-array-ld/targetRefShape> ($d4 <$d5 $d6 ...>) ;
      <https://www.opengis.net/def/binary-array-ld/target> <$targetEntity> .
----

`$dn` are all defined to be integers.  Each object of these RDF statements is an RDF list.

The object of the `bald:sourceRefShape` statement and `bald:targetRefShape` shall be an RDF list with equal numbers of elements.

The sourceRefShape is optional, it is assumed to be the same as the source array `bald:shape`, unless overridden by an explicit sourceRefShape statement.
If the sourceRefShape is not provided, this is inferred to be the same as the defined `bald:shape`.

RefShapes never change the number of elements in an array nor the ordering of extensive (greater than size 1) array shape elements.  A refShape array is only a higher dimensionality shape of a defined array shape, with dimensions of size 1 added to produce the desired dimensionality and dimension ordering.

The lengths of these two RefShape lists shall be the same, they represent the same dimensionality.

The product of the sourceRefShape (if provided) elements shall match the product of the `bald:shape`, the number of elements in the described arrays shall be the same.

The product of the targetRefShape elements shall match the product of the `bald:shape` of the <$targetEntity>, the number of elements in the described arrays shall be the same.


===== Example Shapes and RefShapes

Shapes and RefShapes explicitly define the array dimension relationships that are implicit in the netCDF structure through the named dimensions.

If an array is defined with respect to named nc dimensions (da, db, dc) giving it a shape of (13,17,7) and it references an array defined with respect to dimensions (db) a shape of (17) then the effective reference shape for the relation is a targetRefShape of (1,17,1).
If the same array of shape (13,17,7) references an array defined with respect to dimensions (da) a shape of (13) then the effective reference shape for the relation is a targetRefShape of (13,1,1).

----
dimensions:
    da = 13 ;
    db = 17 ;
    dc = 7 ;
variables:
    int avar(da,db,dc) ;
    int db(db) ;
    int da(da) :
----
is represented as references in the metadata graph as:
----
this:avar a bald:array ;
    bald:shape ( 13 17 7 ) ;
    bald:references [ a bald:Reference ;
            bald:target this:db ;
            bald:targetRefshape ( 1 17 1 ) ],
        [ a bald:Reference ;
            bald:target this:da ;
            bald:targetRefshape ( 13 1 1 ) ] ;
    .
this:db a bald:array ;
   bald:shape ( 17 ) .
this:da a bald:array ;
   bald:shape ( 13 ) .
----

This explicit reference is crucial for cases where there are unique dimensions of the same size, where inference could not be used. Given the generality of these, the standard mandates that targetRefShape shall always be defined, even if it could be inferred by the dimensionality size matching.  This is to aid implementations using this information.

This reflects the explicit dimension naming within netCDF files. The references are stated explicitly in the file using these named dimensions. This standard does not preserve dimension names within the summary metadata graph but does represent these explicit array to array relationships and their cardinality.

If an array, defined with respect to named nc dimensions (de, df, dg), of shape (13,13,13), references an array defined with respect to dimensions (df), of shape (13), then there is no way to infer the correct targetRefShape, it must be specified, e.g. (1,13,1)

----
dimensions:
    de = 13 ;
    df = 13 ;
    dg = 13 ;
variables:
    int bvar(de,df,dg) ;
    int df(df) ;
----
is represented as references in the metadata graph as:
----
this:bvar a bald:array ;
    bald:shape ( 13 13 13 ) ;
    bald:references [ a bald:Reference ;
            bald:target this:df ;
            bald:targetRefshape ( 1 13 1 ) ] ;
    .
this:df  a bald:array ;
    bald:shape ( 13 ) .
----


If an array defined with respect to nc dimensions (di,dj,dk,dl), of shape (13,17,13,7), references an array defined with respect to dimensions (dk, dm), of shape (13,3) then both the source and target reference shape must be defined, e.g. sourceRefShape (13,17,13,7,1) targetRefShape (1,1,13,1,3)

----
dimensions:
    di = 13 ;
    dj = 17 ;
    dk = 13 ;
    dl = 7 ;
    dm = 3 ;
variables:
    int cvar(di,dj,dk,dl) ;
      cvar:bald__references = "lvar" ;
    int lvar(dk,dm) ;
----
is represented as references in the metadata graph as:
----
this:cvar a bald:array ;
    bald:shape ( 13 17 13 7 ) ;
    bald:references [ a bald:Reference ;
            bald:target this:lvar ;
            bald:sourceRefshape ( 13 17 13 7 1 ) ],
            bald:targetRefshape ( 1 1 13 1 3 ) ],
    .
this:lvar a bald:array ;
    bald:shape ( 13 3 ) .
----

Where any ambiguity in ordering exists in the netCDF file for explicitly defined sourceRefShape and targetRefShape instances, due to partial overlap of named dimensions for both netCDf variables, then source reference dimensions shall be ordered before target reference dimensions.

In the above example the size 7 dimension is ordered before the size 3 dimension in the RefShape instances.

===== Mismatched reference 

Where metadata schemes provide further variable reference predicates, it is possible for variable-to-variable references to be defined where a broadcast relationship does not exist.

Applications may treat mismatches between reference definitions and the ability to broadcast as warning conditions, and skip the creation of RDF statements. In this case, it is recommended to continue to create a graph and omit references.  It is accepted that an implementation may treat this as an error condition, and fail to create a graph.  This is an implementation detail.


===== Variable Reference Utility

The definition of the variable reference with its cardinality delivers specific capability to the resulting metadata graph.

References between arrays in a file are provided primarily to support partial access patterns from individual file objects.  Where an element of interest is identified from a metadata graph, this element may be accessed directly, if supported by a suitable data supply interface, without the need to obtain the entire file object.

In order to support partial retrieval, it is essential that the metadata graph provides details on which array variables depend on other array variables and the nature of that dependency.

If two values from an array variable containing millions of elements in a file are requested, which other arrays within the file provide explicit metadata and need to be retrieved, and which elements within those arrays provide locational metadata?  How should the two requested data values be described by metadata?

Without numerical array referencing, the only option for the user is to obtain the whole file and use an alternative netCDF tool to extract the values required with their associated metadata elements.

==== NetCDF Coordinate Variables

NetCDF defines a special type of variable, called a _Coordinate Variable_, which is identified by being one-dimensional and having the same name as the single dimension used to size the variable.

NetCDF-LD interprets Coordinate Variables as a case of variable referencing and includes entries as `bald:references` statements. 
There is an explicit exception to this, which is that self-references, from a coordinate variable to itself, shall not be added to the graph.

NetCDF-LD adds information on the Coordinate Variables, providing the first value, and optionally the last value, if there is more than one value.  The first and last are taken from the order as presented within the file. If the value is encoded as a missing value, then no statement is included within the metadata graph.

NetCDF-LD uses the terms `bald:arrayFirstValue` and `bald:arrayLastValue` to identify these extracts from the Coordinate Data payload within individual statements in the resulting graph.

In this way, searchable information on the location in geospatial and conceptual coordinate space is extracted from the files, whilst the graph size increases by two statements per coordinate variable.  The full coordinate array is not encoded within the metadata graph.

==== Worked Example

Here the definition of a netCDF file, in CDL, with all data array elements set as missing, is presented. It is followed by an RDF graph interpretation of the netCDF, illustrating many of the interpretation features described in this chapter.

----
netcdf tmpMwXy8U {
dimensions:
        pdim0 = 11 ;
        pdim1 = 17 ;
        xy = 2 ;
variables:
        int data_variable1(pdim0, pdim1) ;
                data_variable1:bald__references = "location_variable" ;
                data_variable1:long_name = "Gerald";
                data_variable1:obtype = "metce__SamplingObservation";

        int data_variable2(pdim0, pdim1) ;
                data_variable2:bald__references = "location_variable" ;
                data_variable2:long_name = "Imelda";
                data_variable2:obtype = "metce__SamplingObservation";

        int pdim0(pdim0) ;

        int pdim1(pdim1) ;

        int location_variable(pdim0, pdim1, xy) ;
                location_variable:bald__references = "location_reference_system" ;

        int location_reference_system;
                location_reference_system:pcode = "4897";

        int set_collection ;
                set_collection:bald__references = "data_variable1 data_variable2" ;

        int list_collection ;
                list_collection:bald__references = "( data_variable1 data_variable2 )" ;

// prefix group
group: prefix_list {
  :bald__ = "https://www.opengis.net/def/binary-array-ld/" ;
  :metce__ = "http://codes.wmo.int/common/observation-type/METCE/2013/" ;
  :rdf__ = "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ;
}
// global attributes:
		:bald__isPrefixedBy = "prefix_list" ;

}

----

According to this standard, the netCDF file as defined above is interpreted into RDF, in the terse triple language (TTL) as

----
@prefix bald: <https://www.opengis.net/def/binary-array-ld/> .
@prefix dcat: <http://www.w3.org/ns/dcat#> .
@prefix dct: <http://purl.org/dc/terms/> .
@prefix metce: <http://codes.wmo.int/common/observation-type/METCE/2013/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix this: <file://CDL/multi_array_reference.cdl/> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

this: a bald:Container ;
    dct:format [ a dct:MediaType ;
            dct:identifier <http://vocab.nerc.ac.uk/collection/M01/current/NC/> ] ;
    dcat:distribution [ a dcat:Distribution ;
            dcat:mediaType [ a dct:MediaType ;
                    dct:identifier "application/netcdf" ] ] ;
    bald:contains this:data_variable1,
        this:data_variable2,
        this:list_collection,
        this:location_reference_system,
        this:location_variable,
        this:pdim0,
        this:pdim1,
        this:set_collection ;
    bald:isPrefixedBy "prefix_list" .

this:list_collection a bald:Resource ;
    bald:references ( this:data_variable1 this:data_variable2 ) .

this:set_collection a bald:Resource ;
    bald:references this:data_variable1,
        this:data_variable2 .

this:location_reference_system a bald:Resource ;
    this:pcode "4897" .

this:data_variable1 a bald:Array ;
    this:long_name "Gerald" ;
    this:obtype metce:SamplingObservation ;
    bald:references [ a bald:Reference ;
            bald:target this:pdim1 ;
            bald:targetRefshape ( 1 17 ) ],
        [ a bald:Reference ;
            bald:sourceRefshape ( 11 17 1 ) ;
            bald:target this:location_variable ;
            bald:targetRefshape ( 11 17 2 ) ],
        [ a bald:Reference ;
            bald:target this:pdim0 ;
            bald:targetRefshape ( 11 1 ) ] ;
    bald:shape ( 11 17 ) .

this:data_variable2 a bald:Array ;
    this:long_name "Imelda" ;
    this:obtype metce:SamplingObservation ;
    bald:references [ a bald:Reference ;
            bald:target this:pdim0 ;
            bald:targetRefshape ( 11 1 ) ],
        [ a bald:Reference ;
            bald:sourceRefshape ( 11 17 1 ) ;
            bald:target this:location_variable ;
            bald:targetRefshape ( 11 17 2 ) ],
        [ a bald:Reference ;
            bald:target this:pdim1 ;
            bald:targetRefshape ( 1 17 ) ] ;
    bald:shape ( 11 17 ) .

this:pdim0 a bald:Array ;
    bald:shape ( 11 ) .

this:pdim1 a bald:Array ;
    bald:shape ( 17 ) .

this:location_variable a bald:Array ;
    bald:references [ a bald:Reference ;
            bald:target this:pdim1 ;
            bald:targetRefshape ( 1 17 1 ) ],
        [ a bald:Reference ;
            bald:target this:pdim0 ;
            bald:targetRefshape ( 11 1 1 ) ],
        this:location_reference_system ;
    bald:shape ( 11 17 2 ) .


----

==== Worked Example - Climate and Forecasting Conventions

Variable to variable referencing is a pattern used extensively within the Climate and Forecatsing conventions for netCDF files (CF-netCDF).

CF-netCDF attributes such as `coordinates` can be defined within a specification graph as variable reference attributes, i.e.:

----
cf:coordinates a owl:ObjectProperty ;
    rdfs:range bald:Resource .
----

Given a specification graph definition and an input CF-netCDF file:


----
netcdf orca2_votemper {
dimensions:
        dim0 = 148 ;
        dim1 = 180 ;
        time = 4 ;
        deptht = 4 ;

variables:
        float votemper(time, deptht, dim0, dim1) ;
                votemper:_FillValue = 9.96921e+36f ;
                votemper:standard_name = "sea_water_potential_temperature" ;
                votemper:long_name = "Temperature" ;
                votemper:units = "degC" ;
                votemper:coordinates = "deptht nav_lat nav_lon time" ;
        float deptht(deptht) ;
                deptht:units = "m" ;
                deptht:standard_name = "depth" ;
                deptht:long_name = "Vertical T levels" ;
                deptht:positive = "down" ;
                deptht:title = "deptht" ;
        float nav_lat(dim0, dim1) ;
                nav_lat:units = "degrees" ;
                nav_lat:standard_name = "latitude" ;
                nav_lat:long_name = "Latitude" ;
                nav_lat:nav_model = "Default grid" ;
        float nav_lon(dim0, dim1) ;
                nav_lon:units = "degrees" ;
                nav_lon:standard_name = "longitude" ;
                nav_lon:long_name = "Longitude" ;
                nav_lon:nav_model = "Default grid" ;
        int time(time) ;
                time:units = "hours since 2001-01-01 00:00:00" ;
                time:standard_name = "time" ;
                time:long_name = "Time axis" ;
                time:calendar = "360_day" ;
                time:time_origin = "2001-JAN-01 00:00:00" ;
                time:title = "Time" ;
// global attributes:
                :Conventions = "CF-1.5" ;
----

then the `coordinates` attribute defined on the `votemper` variable is interpreted as a variable to variable reference, creating four explicit reference statements with blank nodes representing the bald:Reference instances.
These explicit bald:references statements are included within the graph alongside the CFTerms:coordinates statements. 

This can be seen within the interpreted metadata graph for this file

----
@prefix CFTerms: <http://def.scitools.org.uk/CFTerms/> .
@prefix NetCDF: <http://def.scitools.org.uk/NetCDF/> .
@prefix bald: <https://www.opengis.net/def/binary-array-ld/> .
@prefix cf_sname: <http://vocab.nerc.ac.uk/standard_name/> .
@prefix dcat: <http://www.w3.org/ns/dcat#> .
@prefix dct: <http://purl.org/dc/terms/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix this: <file://CDL/minVotemper.cdl/> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

this: a bald:Container ;
    NetCDF:Conventions "CF-1.5" ;
    dct:format [ a dct:MediaType ;
            dct:identifier <http://vocab.nerc.ac.uk/collection/M01/current/NC/> ] ;
    dcat:distribution [ a dcat:Distribution ;
            dcat:mediaType [ a dct:MediaType ;
                    dct:identifier "application/netcdf" ] ] ;
    bald:contains this:deptht,
        this:nav_lat,
        this:nav_lon,
        this:time,
        this:votemper .

this:votemper a bald:Array ;
    CFTerms:coordinates this:deptht,
        this:nav_lat,
        this:nav_lon,
        this:time ;
    CFTerms:standard_name "sea_water_potential_temperature" ;
    NetCDF:FillValue "9.96921e+36" ;
    NetCDF:long_name "Temperature" ;
    NetCDF:units "degC" ;
    bald:references [ a bald:Reference ;
            bald:target this:nav_lat ;
            bald:targetRefshape ( 1 1 148 180 ) ],
        [ a bald:Reference ;
            bald:target this:nav_lon ;
            bald:targetRefshape ( 1 1 148 180 ) ],
        [ a bald:Reference ;
            bald:target this:deptht ;
            bald:targetRefshape ( 1 4 1 1 ) ],
        [ a bald:Reference ;
            bald:target this:time ;
            bald:targetRefshape ( 4 1 1 1 ) ] ;
    bald:shape ( 4 4 148 180 ) .

this:deptht a bald:Array ;
    CFTerms:positive "down" ;
    CFTerms:standard_name "depth" ;
    NetCDF:long_name "Vertical T levels" ;
    NetCDF:title "deptht" ;
    NetCDF:units "m" ;
    bald:shape ( 4 ) .

this:nav_lat a bald:Array ;
    this:nav_model "Default grid" ;
    CFTerms:standard_name "latitude" ;
    NetCDF:long_name "Latitude" ;
    NetCDF:units "degrees" ;
    bald:shape ( 148 180 ) .

this:nav_lon a bald:Array ;
    this:nav_model "Default grid" ;
    CFTerms:standard_name "longitude" ;
    NetCDF:long_name "Longitude" ;
    NetCDF:units "degrees" ;
    bald:shape ( 148 180 ) .

this:time a bald:Array ;
    this:time_origin "2001-JAN-01 00:00:00" ;
    CFTerms:calendar "360_day" ;
    CFTerms:standard_name "time" ;
    NetCDF:long_name "Time axis" ;
    NetCDF:title "Time" ;
    NetCDF:units "hours since 2001-01-01 00:00:00" ;
    bald:shape ( 4 ) .


----

=== NetCDF Linked Data on Schema.org ===

This standard recognises that while domain specific vocabularies and detailed RDF representations of datasets in NetCDF are important, there is a growing movement to make use of standardised vocabularies, such as Schema.org, to harmonise the higher-level descriptions of digital assets such as datasets. The goal of this activity is often the promotion of datasets in portals through Search Engine Optimisation and also to provide a common syntax and understanding of the datasets in a consistent language.

To this end, NetCDF-LD also supports a limited description of a netCDF file as Schema.org Dataset through mapping a bald:Container to the Schema.org Dataset class. 

Within the Schema.org representation, the DCAT usage to describe the file type and to provide an optional statement to specify the resolvable location of the file object described above is mapped to Schema.org's DataDownload class and its associated properties (Figure 12).

[#figure-12]
.A sample NetCDF-LD graph cast to the Schema.org vocabulary
image::netcdf_ld_as_schema_dot_org.png

A worked example follows in RDF, encoded using Turtle, the terse triple language (TTL):

----

@prefix so: <http://schema.org/> .

<https://www.ngdc.noaa.gov/thredds/dodsC/arctic/Polar-APP-X_v01r01_Nhem_1400_d20160801_c20160803.nc> a so:Dataset;
	so:name "Extended AVHRR Polar Pathfinder Fundamental Climate Data Record (APPx CDR)" ;
	so:description "The Extended AVHRR Polar Pathfinder (APP-x) version-2 Thematic Climate Data Record (CDR) includes surface temperature, surface albedo, surface and the Top Of the Atmosphere (TOA) shortwave and longwave radiative fluxes, cloud properties (amount, phase, particle size, optical depth,top pressure and temperature, surface and TOA radiative effect), and ice thickness and age. The APP-x CDR has twice daily data at local solar times of 14 and 04(02) for the Arctic(Antarctic) at a spatial resolution of 25 km for both poles." ;
	so:identifier "Polar-APP-X_v01r01_Nhem_1400_d20160801_c20160803.nc" ;
	so:keywords:
        "EARTH SCIENCE > ATMOSPHERE > ATMOSPHERIC RADIATION > RADIATIVE FLUX",
        "EARTH SCIENCE > TERRESTRIAL HYDROSPHERE > SNOW and ICE > ALBEDO" ;
	so:license "No restrictions on access or use" ;
	so:url <https://www.ngdc.noaa.gov/thredds/dodsC/arctic/Polar-APP-X_v01r01_Nhem_1400_d20160801_c20160803.nc/>;
	so:distribution [
		a so:DataDownload ;
		so:contentUrl <https://www.ngdc.noaa.gov/thredds/dodsC/arctic/Polar-APP-X_v01r01_Nhem_1400_d20160801_c20160803.nc/> ;
		so:encodingFormat "application/netcdf", "http://vocab.nerc.ac.uk/collection/M01/current/NC/"
	] .
	
----

=== Implementation Adaptation ===

This standard recognises that there are myriad opportunities for optimisation of large collections of graphs of netCDF files contents.

For example, a series, or collection of netCDF files may share the vast majority of metadata, differing in only one or two key elements, such as a different value for a temporal coordinate, along with different data values.

Implementations may implement many different strategies, reducing the volume of data stored, constructing shared entities to aid query construction or optimisation.

As this standard is targeted at standardising the representation of a single file, it is important that a method for validating consistency is provided which does not preclude useful optimisation steps.

On this basis, it is suggested that an implementation may provide a transformation, such that the graph for an individual file may be derived from a compressed or engineered storage format.

The data storage shall be deemed compliant with this standard if a graph representing a single file may be transformed by the provided transformation into a single file graph that meets the validation rules within this standard.

The format for such transformations is not specified by this standard, it need only provide a suitable RDF graph output.


== Clauses not Containing Normative Material

=== Design principles and Rationale ===

netCDF-Classic-LD allows existing netCDF files, which use the netCDF-classic data model of the legacy netCDF-3 encoding, to be interpreted as Linked Data with minimal changes. netCDF-Classic-LD encoding rules and mechanisms allow users to leverage Linked Data in programming environments using netCDF and to improve interoperability for netCDF files using different combinations of metadata conventions.

A design principle of netCDF-Classic-LD is that it works with existing netCDF classic encoded files. This means existing netCDF libraries can be used to parse files which have been encoded as netCDF-Classic-LD. This also ensures that netCDF-Classic-LD encoded files can be used as simply as netCDF, with no knowledge of RDF.

A key aspect of netCDF-Classic-LD is the introduction of rules for mapping identifiers for netCDF global and variable attributes and variables to Uniform Resource Identifiers (URIs) via _prefix_ and _alias_ mechanisms. Using these mechanisms, netCDF-Classic-LD provides a way to disambiguate attribute names and values shared among different netCDF files via identifiers. Identifiers are the building blocks for defining unambiguous semantics via concept definitions and relationships between concepts.

netCDF-Classic-LD aims to enable any netCDF file to be represented as RDF, if desired, for use with other Linked Data technologies including the RDF query language, SPARQL (Harris and Seaborne 2013). People intending to use netCDF-LD with RDF tools will find it can be used as another RDF syntax, like Turtle (Prud'hommeaux and Carothers 2014).


=== Resource Description Framework

The _Resource Description Framework (RDF)_ is a W3C standard (Hayes and Patel-Schneider 2014).  Information elements consist of RDF statements. An RDF statement consist of three parts: _Subject_, _Predicate_, and _Object_. This is called a _triple_.

Identifiers are a key building block of RDF and _Uniform Resource Identifiers (URIs)_ are used to identify a resource. URIs can appear in each part of a triple, i.e. _Subjects_, _Predicates_ and _Objects_. Where an _Object_ is a _URI_, this may also be a subject for another statement.

Literals are another key part of RDF and are used to capture basic values other than a URI. e.g. strings such as "Gerald", dates such as "1 April 2019", and numbers such as "4897". Literals are associated with a datatype so that it can be parsed. Literals may only appear in the object part of a RDF statement. 

RDF statements are collected together within an _RDF Graph_.

The netCDF-Classic-LD standard maps the netCDF Classic data model encoding onto the RDF information model.


=== Metadata RDF Graph

An _RDF graph_ representing the metadata of multiple files provides a valuable resource for summarising the file collection.

The numerical data within the file is not encoded within the graph, only the metadata.  In general, this means that the graph is orders of magnitude smaller than the data file it summarises.

Having an _RDF graph_ of metadata across a file collection enables the use of Semantic Web technologies to explore, interrogate and visualise the metadata from that file collection in a variety of ways.

**_TODO: insert diagram visualising an RDF graph_**  

The following sections of this standard define how to interpret a netCDF file as an RDF metadata graph.

Multiple graphs may be combined into a single multi-file metadata graph as long as individual file identity is unique across the multi-file metadata graph.

==== Uniform Resource Identifiers within netCDF files

At the core of this standard is the mechanism for encoding and interpreting Uniform Resource Identifiers (URIs) within netCDF files.

These URIs may be declared explicitly within the files, or interpreted from file metadata and external information sources.


==== Identity

In netCDF-Classic-LD, a _netCDF file_ has an identity.  This identity provides the mechanism to obtain the file.  As such it is mutable, it is dependent on how the file is provided.  Two systems may provide an identical file, but in different ways, and hence use different identities.

An explicit identity, i.e. a URL or URI, may be provided during file interpretation.  If no identity is provided, a default identity, a local file URI, will be used.

Each variable within that file has its own identity, defined relative to the file identity.  This is defined using the variable name appended to the file identity and separated by a `/`.

==== Prefix Definition

In netCDF-Classic-LD, the _prefix_ is a mechanism to encode explicit URIs from elements in the _netCDF file_. It is the most straightforward and the most powerful way of doing so. It has two parts: the first part is the declaration of a prefix (or a set of prefixes), the second part is the use of the prefix.

Prefixes are in wide use in a number of domains, including XML and RDF. They allow a URI to be expressed in a compact fashion that saves space, enhances human readability and can mitigate issues with reserved characters.

===== Prefix declaration

A prefix is declared using a name-value-pair that associates a short name (e.g. `cf__`, `bald__`), with a URI. A single prefix declaration is an attribute and a value: the attribute name is the prefix name and the attribute value is the full URI for that prefix. e.g.

----
  `bald__ = http://binary-array-ld.net/latest/`
----

The 'double underscore' character pair: `__` is used as an identifier and as the termination of the prefix; the double underscore is part of the prefix.

The double underscore is interpreted as a special character by this standard: the first use of a double underscore from the start of any string shall be interpreted as a prefixed entity and shall be unpacked into full URIs by aware software if a full URI is defined.

Prefixes are applied across the file they are declared within.  A single dedicated variable shall be used to contain all of the prefixes applied to that file by that file.

The prefix variable is optional.

If included the prefixes variable shall be identified within the file by a single global attribute, using the attribute name `bald__isPrefixedBy`.

If included, the prefixes variable shall include the `bald` prefix declaration.

===== Prefix use

A prefix is used with netCDF file elements as:
----
  <prefix><name>
----

This is interpreted within this standard as a URI, a concatenation of the matching value within the prefix variable and the remainder of the attribute name or value.

The attribute name
----
  `bald__isPrefixedBy` 
----
together with the prefix definition
----
  `bald__ = http://binary-array-ld.net/latest/`
----
is interpreted as
----
  `bald__isPrefixedBy = http://binary-array-ld.net/latest/isPrefixedBy`
----

Prefixes shall end in a URI separator, either a `/` or a `#`.  

The following example, in netCDF Common Data Language (CDL), uses the link:++binary-array-ld.net++[binary-array-ld.net] and the `w3.org rdf-syntax-ns` vocabularies to describe a reference relationship between two variables.

----
netcdf tmpMwXy8U {
dimensions:
	pdim0 = 11 ;
	pdim1 = 17 ;
variables:
	int a_variable(pdim0, pdim1) ;
		parent_variable:rdf__type = "bald__Array" ;
		parent_variable:bald__references = "b_variable" ;
	int b_variable(pdim0, pdim1) ;
		child_variable:rdf__type = "bald__Reference" ;
		child_variable:bald__array = "b_variable" ;
	int prefix_list ;
		prefix_list:bald__ = "http://binary-array-ld.net/latest/" ;
		prefix_list:rdf__ = "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ;

// global attributes:
		:bald__isPrefixedBy = "prefix_list" ;
}
----

In this example:

* `rdf__type` is interpreted as http://www.w3.org/1999/02/22-rdf-syntax-ns#type
* `bald__array` is interpreted as http://binary-array-ld.net/latest/array



==== Alias Definition

Alongside the definition of prefixes, explicit aliases may be defined via netCDF-Classic-LD conventions within the _netCDF file_, or as a scope for a _netCDF file_ during parsing.  Aliases enable controlled attribute names to be interpreted as URIs.

For an entity in an alias graph to be considered as an alias, the entity will define a statement:

----
  <$entity> <http://purl.org/dc/terms/identified> "$Literal" .
----

The Literal object of this statement is the alias name.

An alias that may be used as an attribute name alias shall define its Type as

----
  <$entity> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/1999/02/22-rdf-syntax-ns#Property> .
----

or

----
  <$entity> <http://www.w3.org/1999/02/22-rdf-syntax-ns#type> <http://www.w3.org/2002/07/owl#ObjectProperty> .
----


The alias mechanism is less flexible than the prefix mechanism. It does enable interpretation of atribute names directly, making it useful for existing standards and existing files.

Aliases are applied across the file they are declared for.

Aliases are declared as a set of RDF graphs. These RDF graphs are commonly provided as URIs, to be obtained during parsing and file metadata interpretation.

The RDF graphs shall be combined and treated as a single alias scope for the file.


==== Attribute Names

In order to map netCDF metadata to RDF, all global and variable attributes are interpreted as RDF statements.  This requires that all attribute names are interpreted as URIs.

A parsing process shall map attribute names to URIs using prefix definitions first, then map attribute names to URIs aliases.

An attribute name shall be mapped to an alias URI if, and only if, there is an exact match for the full attribute name as a `dct:notation` (expand to full uri) for an entity within the alias graph where that entity declares a statement within its defining graph.

----
  <entity> <rdf:type> <rdfs:ObjectProperty> .
----

That defining graph needs to be provided to netCDF-Classic-LD aware software at the time of parsing the file, so that it can be interpreted.

An error is thrown if multiple aliases match an attribute name in a _netCDF file_ due to a conflict in unambiguously identifying the declared alias scope.

All remaining attribute names shall be mapped to local identifiers, using the file identity and variable identity (ref{}) to form a locally applicable URI.

==== Variable to Variable References

The value of an attribute may be a reference to another variable, or multiple variables, within the file.
The process of establishing identity for each variable within the file enables this reference to be interpreted as a URI.
In this way, the RDF approach to having objects that are links to subjects, chaining statements into graphs, is implemented.

For a reference to be identified, the predicate that defines that reference must identify itself as suitable for variable to variable referencing.  No references will be inferred for predicates that do not identify themselves in this way.

To identify a predicate as a variable to variable reference predicate, that predicate shall provide a statement that explicitly opts into this behaviour.  The simplest way to do this is to include the statement

----
  <{predicate}> rdfs:range bald:Subject .
----

This standard recognises that some vocabularies already use the rdfs:range for specific purposes.  To enable particular scenarios to be supported, then a subClassOf approach may be used.  This has potential implications for reasoning, so should be adopted only where it has value, and the implications are understood.  The simple statement above is the advised option where it can be implemented.

This standard shall infer a variable to variable reference where an rdfs:range target is also identifed as an rdfs:subClassOf bald:Subject

----
  <{predicate}> rdfs:range <{AClass}> .
  <{AClass}> rdfs:subClassOf bald:Subject .
----


References to variables are implemented in netCDF files by defining the value of an attribute as the name of a variable, or as a space separated set of names of variables, or as a parenthesis bound space separated list of names of variables.

A set of references is explicitly unordered whilst a list of references is explicitly ordered.

CDL defining a set of references:
----
  int set_collection ;
    set_collection:bald__references = "data_variable1 data_variable2" ;
----

will be interpreted into RDF(turtle) as:
----
  ns1:set_collection a bald:Subject ;
      bald:references ns1:data_variable1_pdim0_ref,
                      ns1:data_variable2_pdim0_ref .
----


CDL defining a list of references:
----
  int list_collection ;
    list_collection:bald__references = "( data_variable1 data_variable2 )" ;
----

will be interpreted into RDF(turtle) as:
----
  ns1:list_collection a bald:Subject ;
      bald:references ( ns1:data_variable1_pdim0_ref ns1:data_variable2_pdim0_ref ) .
----

All variable names shall be within the file, or no references shall be interpreted.  There shall be no partial matching.

If such matching fails, the fall back option is to ignore the potential for references and leave the attribute value as a Literal.

==== Attribute Values

In RDF, objects may be Literals or URIs, therefore attribute values are conditionally interpreted as Literals or as URIs.

A parsing process shall map attribute values to URIs using identified prefixes first.

===== Attribute Variable References

The value of a variable attribute may be an internal reference to another variable within the file.

For a variable reference to be declared, three conditions shall be met.

Condition one: the value is a string which exactly matches the name of a variable within the file.

Condition two: the attribute name is already interpreted as a URI, defining an entity, external to the file.

Condition three: the attribute name entity declares and <rdfs:range> of <bald:subject>.

An identified attribute reference shall map the attribute value to the identify of the matched variable within the file.

This identification takes place after prefixes are identified and mapped.

===== Attribute Value Aliases

After prefix and reference interpretation, remaining attribute values are mapped to URIs using the alias graph.

An attribute value shall be mapped to an alias URI if and only if there is an exact match for the full attribute value as a dct:notation (expand to full uri) for an entity within the alias graph.

If multiple aliases match an attribute name, this is an error condition, the declared alias scope cannot be uniquely applied to the file.

===== Attribute Value Literals

All remaining attribute values shall be left unchanged and declared as instances of <rdf:Literal>.

=== NetCDF Dimensions

NetCDF makes strong inferences regarding how variables are defined by dimensions

NetCDF files define named dimensions, 'dims'.  Each dimension defines a size, which is used as an array dimension.  NetCDF Variables use dimensions to define their size and shape and to define some implicit references between each other.

NetCDF-Classic-LD uses the dimensions to interpret the size and shape of a variable array.

NetCDF-Classic-LD does not explicity encode the dimensions: only the sizing and referencing information.  In cases where dimensions do not have a netCDF coordinate variable defined, this results in the name of the dimension being lost.

Extensive Variables are variables defined with respect to one or more dimensions.

In netCDF-Classic-LD, the size and shape of each extensive variable is explicitly stored as a statement made with respect to that variable.  The predicate bald:shape is used.  Objects of this predicate shall be rdf:Literal instances.

Each extensive variable shall be described by a statement.

----
  <$entity> <http://binary-array-ld.net/latest/shape> ($d0 $d1 $d2)
----

where `$dn` is an integer, taken from the defined dimension size in the netCDF file and the count of the number of values is the dimensionality of the variable.

The object of this statement is an RDF List.


==== Variable References and Dimensions

NetCDF-Classic-LD uses the dimensions to interpret references between variables and to interpret how the shapes of the variable arrays relate.

Each variable reference between variables defined with respect to netCDF dimensions is assumed to be an array to array relationship and that the arrays can be broadcast to enable a common indexing approach.

This interpretation means that it can be expected that the child in the reference relationship can be viewed with the same dimensionality as the parent, with size one values for dimensions that are to be broadcast over.

Note: this is a key feature of netCDF dimensions: defining the size and commonality of array dimensions for variables.

In each case where a variable to variable reference is inferred within a netCDF file and both of the variables are defined with respect to one or more dimensions, the nature of that reference from the perspective of the arrays will be explicitly encoded within the RDF graph.

The inferencing of how array dimensions are matched and how this enables the interpretation of array broadcasting is subtle and implicit in netCDF, and specific to netCDF.

This information is unpacked and stored in a general fashion within the RDF graph.

All extensive variables have a shape encoded in the RDF graph.  In order to interpret references, it is commonly required that a statement, similar to the shape, is encoded, showing the reshaped shape that an array needs to be in order to properly broadcast.
NetCDf-Classic-LD explicitly includes all reference statements, even where the broadcast relationship can be inferred, for clarity and to aid comprehension.

A reshape array has the same total number of elements as the original array, but includes extra dimensions, of size 1, defining the order which the extensive dimensions are handled in.

To hold this information, netCDF-Classic-LD creates a new entity within the graph, representing this relationship, a `<$referenceEntity>`.

This `<$referenceEntity>` is referenced by the `<$parentEntity>` using the predicate `<http://binary-array-ld.net/latest/references>`, i.e.:

----
  <$parentEntity> <http://binary-array-ld.net/latest/references> <$referenceEntity>
----

The `<$referenceEntity>` is defined to be of type `<http://binary-array-ld.net/latest/Reference>` and is expected to carry a single reference to the child entity in the relationship and a `bald:childBroadcast` statement defining the expansion of the child array to the same shape as the parent. i.e.:

----
  <$referenceEntity> a <http://binary-array-ld.net/latest/Reference> ;
      <http://binary-array-ld.net/latest/childBroadcast> ($d1 $d2 $d3) ;
      <http://binary-array-ld.net/latest/array> <$childEntity> .
----

`$dn` are all defined to be integers.  The object of this statement is an RDF list.

There is an optional statement predicate available: `<http://binary-array-ld.net/latest/childBroadcast>`, for the rare cases where both parent and child arrays have to be broadcast to a common shape. 

===== Mismatched reference 

Where metadata schemes provide further variable reference predicates, it is possible for variable to variable references to be defined where a broadcast relationship does not exist.

Applications may treat mismatches between reference definitions and the ability to broadcast as warning conditions, and skip the creation of statements, or as error conditions, and fail to create a graph.  This is an implementation detail.

==== NetCDF Coordinate Variables

NetCDF defines a special type of variable, called a Coordinate Variable, which is identified by being one-dimensional and having the same name as the single dimension used to size the variable.

NetCDF-Classic_LD interprets Coordinate Variables as a case of variable referencing and includes entries as `bald:references` statements. 


=== Worked Example

Here the definition of a netCDF file, in CDL, with all data array elements set as missing, is presented. It is followed by an RDF graph interpretation of the netCDF, illustrating many of the interpretation features desribed in this chapter.

----
netcdf multi_array_reference.cdl {
dimensions:
	pdim0 = 11 ;
	pdim1 = 17 ;
variables:
        int prefix_list ;
  		prefix_list:bald__ = "http://binary-array-ld.net/latest/" ;
		prefix_list:metce__ = "http://codes.wmo.int/common/observation-type/METCE/2013/" ;
  		prefix_list:rdf__ = "http://www.w3.org/1999/02/22-rdf-syntax-ns#" ;
		
	int data_variable1(pdim0, pdim1) ;
		data_variable1:bald__references = "location_variable" ;
		data_variable1:long_name = "Gerald";
		data_variable1:obtype = "metce__SamplingObservation";

        int data_variable2(pdim0, pdim1) ;
		data_variable2:bald__references = "location_variable" ;
		data_variable2:long_name = "Imelda";
		data_variable2:obtype = "metce__SamplingObservation";

        int pdim0(pdim0) ;

        int pdim1(pdim1) ;

	int location_variable(pdim0, pdim1) ;
		location_variable:bald__references = "location_reference_system" ;

	int location_reference_system;
		location_reference_system:pcode = "4897";

	int set_collection ;
	        set_collection:bald__references = "data_variable1 data_variable2" ;

	int list_collection ;
	        list_collection:bald__references = "( data_variable1 data_variable2 )" ;


// global attributes:
		:bald__isPrefixedBy = "prefix_list" ;

}
----

According to this standard, the netCDF file as defeined above is interpreted into RDF, in the terse triple language (TTL) as

----
@prefix bald: <http://binary-array-ld.net/latest/> .
@prefix metce: <http://codes.wmo.int/common/observation-type/METCE/2013/> .
@prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix this: <file://CDL/multi_array_reference.cdl/> .
@prefix xml: <http://www.w3.org/XML/1998/namespace> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

<file://CDL/multi_array_reference.cdl> a bald:Container ;
    bald:contains this:data_variable1,
        this:data_variable1_pdim0_ref,
        this:data_variable1_pdim1_ref,
        this:data_variable2,
        this:data_variable2_pdim0_ref,
        this:data_variable2_pdim1_ref,
        this:list_collection,
        this:location_reference_system,
        this:location_variable,
        this:location_variable_pdim0_ref,
        this:location_variable_pdim1_ref,
        this:pdim0,
        this:pdim1,
        this:set_collection ;
    bald:isPrefixedBy "prefix_list" .

this:list_collection a bald:Subject ;
    bald:references ( this:data_variable1 this:data_variable2 ) .

this:set_collection a bald:Subject ;
    bald:references this:data_variable1,
        this:data_variable2 .

this:data_variable1_pdim0_ref a bald:Reference,
        bald:Subject ;
    bald:array this:pdim0 ;
    bald:childBroadcast ( 11 1 ) .

this:data_variable1_pdim1_ref a bald:Reference,
        bald:Subject ;
    bald:array this:pdim1 ;
    bald:childBroadcast ( 1 17 ) .

this:data_variable2_pdim0_ref a bald:Reference,
        bald:Subject ;
    bald:array this:pdim0 ;
    bald:childBroadcast ( 11 1 ) .

this:data_variable2_pdim1_ref a bald:Reference,
        bald:Subject ;
    bald:array this:pdim1 ;
    bald:childBroadcast ( 1 17 ) .

this:location_reference_system a bald:Subject ;
    this:pcode "4897" .

this:location_variable_pdim0_ref a bald:Reference,
        bald:Subject ;
    bald:array this:pdim0 ;
    bald:childBroadcast ( 11 1 ) .

this:location_variable_pdim1_ref a bald:Reference,
        bald:Subject ;
    bald:array this:pdim1 ;
    bald:childBroadcast ( 1 17 ) .

this:data_variable1 a bald:Array ;
    this:long_name "Gerald" ;
    this:obtype metce:SamplingObservation ;
    bald:references this:data_variable1_pdim0_ref,
        this:data_variable1_pdim1_ref,
        this:location_variable ;
    bald:shape ( 11 17 ) .

this:data_variable2 a bald:Array ;
    this:long_name "Imelda" ;
    this:obtype metce:SamplingObservation ;
    bald:references this:data_variable2_pdim0_ref,
        this:data_variable2_pdim1_ref,
        this:location_variable ;
    bald:shape ( 11 17 ) .

this:location_variable a bald:Array ;
    bald:references this:location_reference_system,
        this:location_variable_pdim0_ref,
        this:location_variable_pdim1_ref ;
    bald:shape ( 11 17 ) .

this:pdim0 a bald:Array,
        bald:Reference ;
    bald:array this:pdim0 ;
    bald:shape ( 11 ) .

this:pdim1 a bald:Array,
        bald:Reference ;
    bald:array this:pdim1 ;
    bald:shape ( 17 ) .

----

